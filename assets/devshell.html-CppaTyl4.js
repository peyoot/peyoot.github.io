import{_ as e,o as i,c as l,b as d}from"./app-oTA4_50g.js";const a={},n=d(`<h1 id="devshell简介" tabindex="-1"><a class="header-anchor" href="#devshell简介"><span>devshell简介</span></a></h1><p>在Yocto的编译过程中，有时我们只需要编译特定的设备树或内核模块，而不是整个linux构件，这时可以进入devshell来快速开发迭代。devshell是一个设置好yocto开发环境的终端，用户可以手动修改内核模块或设备树源码，通过make命令快速获得更改后的部件。</p><h1 id="devshell之内核选项开关和模块编译" tabindex="-1"><a class="header-anchor" href="#devshell之内核选项开关和模块编译"><span>devshell之内核选项开关和模块编译</span></a></h1><p>进入yocto的开发环境后，执行</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>bitbake -c devshell linux-dey
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会打开一个devshell，并停在linux内核源码目录下，等待用户执行命令，此时，build目录为空，内核编译所需的.config文件还不存在。 内核配置在：tmp/work/ccmp25_dvk-dey-linux/linux-dey/6.6/git/arch/arm64/configs$ 以ccmp25为例，bitbake镜像时会在tmp/work/ccmp25_dvk-dey-linux/linux-dey/6.6这个目录生成对应机器的defconfig，以此在build目录下生成.config。 但devshell打开后，还没有生成内核配置.config，此时如果要用对应的机器配置，可以执行</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>make ccmp2_defconfig  这会应用默认的板级配置ccmp2_defconfig
make menuconfig    打开图型化内核选项配置菜单
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>保存后，可以直接bitbake linux-dey，继而编译出更改内核选项的固件。如果不放心，可以在build内的.config里查询相关的配置项，不过任何修改在bitbake -c cleansstate linux-dey之后就会被清空。</p><p>如果我们想得到cfg配置片段，就要进入build目录</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>cd tmp/work/ccmp25_dvk-dey-linux/linux-dey/6.6/build
cp .config.old .config.orig
回到项目目录
bitbake -c diffconfig linux-dey

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令会在linux-dey/6.6下生成一个：fragment.cfg，包含了内核选项的变更，以便整合到linux的bbappend配方当中。</p><p>但有时我们只是临时测试，也可以在devshell里临时打开某个开关，比如：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>bitbake -c devshell linux-dey     # 进 shell
make ccmp2_defconfig
# 在linux的build目录执行：
echo &#39;CONFIG_TOUCHSCREEN_ADS7846_DEBUG=y&#39; &gt;&gt; .config
make Image.gz -j4
# 编译时间较长，会生成Image.gzin

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要重命名为相应平台对应的名称，比如Image.gz-ccmp25-dvk.bin，再把旧内核重命名备份，用新的替代。</p><h1 id="修改编译驱动程序" tabindex="-1"><a class="header-anchor" href="#修改编译驱动程序"><span>修改编译驱动程序</span></a></h1><h2 id="准备内核驱动编译环境" tabindex="-1"><a class="header-anchor" href="#准备内核驱动编译环境"><span>准备内核驱动编译环境</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>make ccmp2_defconfig
make modules_prepare
先构建一次完整的内核模块
make -j$(nproc) modules
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="修改和编译特定目录驱动模块" tabindex="-1"><a class="header-anchor" href="#修改和编译特定目录驱动模块"><span>修改和编译特定目录驱动模块</span></a></h2><p>make drivers/usb/serial/ modules</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>编译完成后，.ko 文件会生成在build目录相应的位置。
加载测试：
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>insmod /usr/lib/modules/$(uname -r)/kernel/drivers/input/touchscreen/ads7846.ko</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div>`,22),t=[n];function s(c,r){return i(),l("div",null,t)}const v=e(a,[["render",s],["__file","devshell.html.vue"]]),u=JSON.parse('{"path":"/zh/deyaio/wiki/devshell.html","title":"devshell简介","lang":"zh-CN","frontmatter":{"description":"devshell简介 在Yocto的编译过程中，有时我们只需要编译特定的设备树或内核模块，而不是整个linux构件，这时可以进入devshell来快速开发迭代。devshell是一个设置好yocto开发环境的终端，用户可以手动修改内核模块或设备树源码，通过make命令快速获得更改后的部件。 devshell之内核选项开关和模块编译 进入yocto的开发...","head":[["meta",{"property":"og:url","content":"https://peyoot.github.io/zh/deyaio/wiki/devshell.html"}],["meta",{"property":"og:title","content":"devshell简介"}],["meta",{"property":"og:description","content":"devshell简介 在Yocto的编译过程中，有时我们只需要编译特定的设备树或内核模块，而不是整个linux构件，这时可以进入devshell来快速开发迭代。devshell是一个设置好yocto开发环境的终端，用户可以手动修改内核模块或设备树源码，通过make命令快速获得更改后的部件。 devshell之内核选项开关和模块编译 进入yocto的开发..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"devshell简介\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"准备内核驱动编译环境","slug":"准备内核驱动编译环境","link":"#准备内核驱动编译环境","children":[]},{"level":2,"title":"修改和编译特定目录驱动模块","slug":"修改和编译特定目录驱动模块","link":"#修改和编译特定目录驱动模块","children":[]}],"git":{},"autoDesc":true,"filePathRelative":"zh/deyaio/wiki/devshell.md"}');export{v as comp,u as data};
